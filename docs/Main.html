<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Live Tab Sharing — Final</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/4.5.2/flatly/bootstrap.min.css"/>
  <style>
    :root{
      --card-radius:18px;
      --muted:#6b7280;
      --accent:#2563eb;
      --bg:#f6f8fb;
      --panel:#ffffff;
      --star-color:#f59e0b;
      --accent-2:#0ea5a4;
    }
    html,body{height:100%;box-sizing:border-box}
    body{background:linear-gradient(180deg,#eef6ff 0%, #fbfcff 100%);font-family:Inter, 'Segoe UI', Roboto, system-ui, sans-serif;margin:0;padding:8px;color:#111}

    /* TOP FRAME */
    .top-frame { max-width:1320px; margin:10px auto; display:flex; align-items:center; justify-content:space-between; gap:12px; }
    .top-left-logo { background:var(--panel); border-radius:16px; padding:12px 16px; display:flex; align-items:center; gap:10px; box-shadow:0 8px 22px rgba(16,24,40,.06); }
    .top-center { flex:1; display:flex; gap:14px; align-items:center; justify-content:center; }
    .top-box { width:320px; height:56px; background:var(--panel); border-radius:12px; display:flex; align-items:center; justify-content:center; box-shadow:0 6px 20px rgba(16,24,40,.04); font-weight:800; font-size:16px; }
    .top-box.tokens { width:220px; }
    .top-user { background:var(--panel); padding:8px 18px; border-radius:28px; display:flex; align-items:center; gap:10px; box-shadow:0 8px 24px rgba(12,30,60,.04); font-weight:800; }

    /* Stage layout */
    .stage{max-width:1320px;margin:0 auto;height:calc(100vh - 160px);display:flex;align-items:flex-start;gap:28px}

    /* LEFT info column (kept smaller) */
    .left-col{width:260px;display:flex;flex-direction:column;gap:14px}
    .logo-top{height:66px;width:220px;border-radius:12px;background:var(--panel);display:flex;align-items:center;padding:8px 14px;box-shadow:0 8px 22px rgba(16,24,40,.06);position:relative}
    .logo-top img{max-width:100%;max-height:48px;display:block}
    .info-card{flex:1;border-radius:14px;background:var(--panel);padding:18px;box-shadow:0 10px 30px rgba(16,24,40,.04);position:relative;overflow:hidden;display:flex;flex-direction:column}
    .big-answer{margin-top:12px;background:linear-gradient(180deg,#fbfdff,#f8fbff);border-radius:12px;padding:18px;border:2px solid rgba(0,0,0,.05);flex:1}

    /* viewer area (new big layout; everything larger) */
    .viewer-area { max-width:1320px; margin:8px auto; }
    .viewer-old { display:grid; grid-template-columns:300px 1fr; gap:18px; align-items:start; height:calc(100vh - 260px); }

    .players-panel { background:#f3f3f3; border-radius:20px; padding:18px; border:2px solid #bdbdbd; box-shadow: inset 0 2px 0 rgba(255,255,255,.6); height:100%; display:flex; flex-direction:column; }
    .players-panel h3 { margin:0; font-size:28px; text-align:center; font-weight:900; letter-spacing:0.6px; }
    .players-list { margin-top:18px; display:flex; flex-direction:column; gap:14px; padding:6px; border-radius:12px; background:linear-gradient(180deg,#fff,#f4f4f4); border:2px solid rgba(0,0,0,.06); flex:1; overflow:auto; }
    .player-item { display:flex; align-items:center; justify-content:space-between; padding:16px 12px; border-radius:12px; border:2px solid rgba(0,0,0,.08); background:#fbfbfb; cursor:pointer; font-size:18px; }
    .player-item.selected { outline:6px solid rgba(0,0,0,.04); background:#f0f8ef; }
    .player-item .name { font-weight:900; font-size:18px; }
    .status-dot { width:22px; height:22px; border-radius:5px; border:2px solid rgba(0,0,0,.06); margin-left:12px; }
    .add-player-btn { margin-top:12px; width:100%; padding:12px; border-radius:10px; background:#e8e8e8; border:2px solid rgba(0,0,0,.08); font-weight:900; font-size:16px; cursor:pointer; }

    .center-panel { background:#ececec; border-radius:26px; padding:28px; border:3px solid rgba(0,0,0,.08); min-height:640px; position:relative; display:flex; flex-direction:column; }
    .current-player-badge { display:inline-block; padding:12px 16px; border-radius:10px; border:2px solid rgba(0,0,0,.12); background:#f6f6f6; font-weight:900; margin-bottom:18px; font-size:18px; }
    .share-canvas { flex:1; border-radius:18px; background:#efefef; display:flex; align-items:center; justify-content:center; font-size:44px; color:#666; text-align:center; margin-top:8px; position:relative; overflow:hidden; }
    .downtime { margin-top:18px; color:#c00; font-weight:800; text-decoration:underline; cursor:default; }

    /* arrow inside center frame (top-right) */
    .center-panel .view-arrow { position:absolute; top:18px; right:18px; width:56px; height:56px; border-radius:10px; border:2px solid rgba(0,0,0,.1); display:flex; align-items:center; justify-content:center; background:#f7f7f7; font-weight:900; cursor:pointer; box-shadow:0 8px 20px rgba(0,0,0,.04); }

    /* buy modal */
    .modal-overlay { position:fixed; left:0; top:0; right:0; bottom:0; background:rgba(0,0,0,.45); display:flex; align-items:center; justify-content:center; z-index:9999; }
    .modal { width:760px; background:var(--panel); border-radius:14px; padding:18px; box-shadow:0 30px 90px rgba(0,0,0,.35); }
    .modal h4 { margin:0 0 12px 0; }
    .sale-list { display:flex; flex-direction:column; gap:10px; max-height:420px; overflow:auto; }

    /* host small controls */
    .host-controls { display:flex; gap:8px; margin-top:12px; }

    .small-muted{color:var(--muted);font-size:.95rem}
    .toast{position:fixed;right:18px;bottom:18px;background:#111;color:white;padding:10px 14px;border-radius:8px;opacity:.95}

    @media(max-width:1100px){
      .viewer-old{grid-template-columns:1fr;gap:12px;height:auto}
      .players-panel{width:100%}
      .center-panel{min-height:380px}
      .top-box{width:120px}
    }
  </style>
</head>
<body>

  <!-- TOP FRAME -->
  <div class="top-frame">
    <div class="top-left-logo" id="topLogo">
      <img src="LogoInit.jpg" alt="Logo" style="height:44px" onerror="this.style.display='none'">
      <div style="font-weight:900;color:var(--accent);font-size:18px">Roblox Life SHARE</div>
    </div>

    <div class="top-center">
      <div class="top-box" id="topRect1"> <!-- big rectangle left (e.g. search or info) -->
        <span id="topRect1Text">Live Tab Sharing</span>
      </div>
      <div class="top-box tokens" id="topRect2">Tokens: <span id="tokensDisplay">0</span></div>
    </div>

    <div class="top-user" id="topUser">
      <div id="usernameDisplay">Guest</div>
      <button id="userAddBtn" title="Create/Add">+</button>
    </div>
  </div>

  <!-- AUTH stage (unchanged) -->
  <div class="stage" id="authStart">
    <div class="left-col">
      <div class="logo-top" id="leftLogo">
        <img id="leftLogoImg" src="LogoInit.jpg" alt="Logo" onerror="this.style.display='none'">
        <div class="logo-fallback" id="leftLogoFallback" style="display:none">
          <div class="line1">R<span style="color:var(--accent)">oblox</span></div>
          <div class="line2">Life SHARE</div>
        </div>
      </div>

      <div class="info-card" id="infoCard">
        <h5 id="mainQTitle">What is this for?</h5>
        <div class="big-answer" id="mainAnswer">
          <div class="answer-text">
            Live Tab Sharing lets a host share a browser tab or entire screen in real time with viewers. A host creates a Player, starts sharing (video-only by default), and viewers connect using the Player's PeerID. Hosts control who stays (kick), select stream quality, and may enable remote control. Streams use WebRTC (encrypted); Firebase stores only session metadata (no media recordings are stored by default).
          </div>
        </div>

        <div class="question-buttons" style="margin-top:14px">
          <div id="qBtn1" class="q-btn">Why choose us?</div>
          <div id="qBtn2" class="q-btn">What about privacy?</div>
        </div>
      </div>
    </div>

    <!-- CENTER: auth card -->
    <div class="center-col">
      <div class="auth-card" role="main" aria-labelledby="authTitle">
        <div class="corner-logo" id="cornerLogo">
          <img id="cornerLogoImg" src="LogoInit.jpg" alt="Logo" style="display:block" onerror="this.style.display='none';document.getElementById('cornerLogoFallback').style.display='block'">
          <div id="cornerLogoFallback" style="display:none;font-family:'Segoe UI',Arial;text-align:center">
            <div style="font-size:12px;font-weight:800;color:var(--accent)">Roblox Life</div>
            <div style="font-size:15px;font-weight:900;color:#222">SHARE</div>
          </div>
        </div>

        <div class="auth-tabs">
          <div id="tabLogin" class="tab active">LOGIN</div>
          <div id="tabRegister" class="tab">REGISTER</div>
        </div>

        <div class="auth-body" id="authBody">
          <!-- LOGIN -->
          <div id="loginForm" style="width:100%;display:flex;flex-direction:column;align-items:center;gap:12px">
            <input id="visualEmail" class="big-input" placeholder="Username/Email..." type="email" />
            <input id="visualPassword" class="big-input" placeholder="Password..." type="password" />
            <a id="forgotLink" class="muted-link">Forgot your password</a>
            <button id="visualSubmit" class="submit-btn">SUBMIT</button>
            <div id="loginMsg" class="small-muted" style="margin-top:6px"></div>
          </div>

          <!-- REGISTER -->
          <div id="registerForm" style="width:100%;display:none;flex-direction:column;align-items:center;gap:12px">
            <input id="regEmail" class="big-input" placeholder="Correo" type="email" />
            <input id="regPassword" class="big-input" placeholder="Contraseña" type="password" />
            <input id="regUsername" class="big-input" placeholder="Nombre (username público)" type="text" />
            <div style="display:flex;gap:8px">
              <button id="registerBtnVisual" class="submit-btn" style="width:140px">Crear</button>
              <button id="cancelRegVisual" class="submit-btn" style="width:140px;background:#fff;color:#111;border:1px solid rgba(0,0,0,.06)">Cancelar</button>
            </div>
            <div id="regMsg" class="small-muted"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- RIGHT: reviews rail -->
    <div class="right-col">
      <div class="reviews-rail" aria-hidden="false">
        <div style="text-align:center"><h5>REVIEWS</h5></div>
        <div class="stars-vertical" id="starsRail" style="margin-top:12px">
          <svg class="star-big" viewBox="0 0 24 24"><path fill="var(--star-color)" d="M12 .587l3.668 7.431L23.5 9.75l-5.667 5.535L19.335 24 12 19.897 4.665 24l1.502-8.715L.5 9.75l7.832-1.732z"/></svg>
          <svg class="star-big" viewBox="0 0 24 24"><path fill="var(--star-color)" d="M12 .587l3.668 7.431L23.5 9.75l-5.667 5.535L19.335 24 12 19.897 4.665 24l1.502-8.715L.5 9.75l7.832-1.732z"/></svg>
          <svg class="star-big" viewBox="0 0 24 24"><path fill="var(--star-color)" d="M12 .587l3.668 7.431L23.5 9.75l-5.667 5.535L19.335 24 12 19.897 4.665 24l1.502-8.715L.5 9.75l7.832-1.732z"/></svg>
          <svg class="star-big" viewBox="0 0 24 24"><path fill="var(--star-color)" d="M12 .587l3.668 7.431L23.5 9.75l-5.667 5.535L19.335 24 12 19.897 4.665 24l1.502-8.715L.5 9.75l7.832-1.732z"/></svg>
          <svg class="star-big" viewBox="0 0 24 24"><defs><linearGradient id="gPartialV" x1="0" x2="1" y1="0" y2="0"><stop offset="0%" stop-color="var(--star-color)"/><stop offset="92%" stop-color="var(--star-color)"/><stop offset="92.1%" stop-color="#e6e6e6"/><stop offset="100%" stop-color="#e6e6e6"/></linearGradient></defs><path fill="url(#gPartialV)" d="M12 .587l3.668 7.431L23.5 9.75l-5.667 5.535L19.335 24 12 19.897 4.665 24l1.502-8.715L.5 9.75l7.832-1.732z"/></svg>
        </div>

        <div class="rating-bubble" style="margin-top:18px">4.92 / 5</div>
      </div>
    </div>
  </div>

  <!-- VIEWER area (big new layout) -->
  <div id="viewerFull" style="display:none;" class="viewer-area">
    <div class="viewer-old">
      <!-- LEFT: Players column -->
      <div class="players-panel" aria-label="Players panel">
        <h3>PLAYERS</h3>
        <div class="players-list" id="playersListViewer">
          <!-- rendered by renderPlayersViewer() -->
        </div>
        <button id="addPlayer" class="add-player-btn">Add / Buy Player</button>
      </div>

      <!-- CENTER: large sharing canvas -->
      <div class="center-panel" id="centerShare">
        <div style="display:flex;align-items:center;justify-content:space-between">
          <div class="current-player-badge" id="currentPlayerBadge">Select A Player</div>
          <div style="display:flex;gap:8px;align-items:center">
            <div class="muted small" id="shareStatusLabel">Status: —</div>
          </div>
        </div>

        <div id="viewerVideoContainer" class="share-canvas">
          <div id="selectMessage">Select A Player</div>
        </div>

        <div class="view-arrow" id="viewArrow" title="Back">◀</div>
      </div>
    </div>
  </div>

  <!-- BUY modal -->
  <div id="buyModal" style="display:none;">
    <div class="modal-overlay" id="buyOverlay">
      <div class="modal" role="dialog" aria-modal="true">
        <h4>Buy Available Players</h4>
        <div id="saleList" class="sale-list"></div>
        <div style="display:flex;justify-content:flex-end;margin-top:12px">
          <button id="closeBuy" class="submit-btn" style="width:120px;background:#fff;color:#111;border:1px solid rgba(0,0,0,.08)">Close</button>
        </div>
      </div>
    </div>
  </div>

  <!-- HOST APP area -->
  <div id="appMain" style="display:none">
    <div style="max-width:1200px;margin:18px auto;padding:18px;background:var(--panel);border-radius:12px;box-shadow:0 12px 36px rgba(12,30,60,.04)">
      <h3>Host view (Players)</h3>
      <div id="playersGrid" style="margin-top:12px;display:grid;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));gap:12px"></div>
    </div>
  </div>

  <!-- Firebase & PeerJS -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js"></script>

  <script>
    /*********************** CONFIG ***********************/
    const firebaseConfig = {
      apiKey: "AIzaSyDLQGyXjRwrJ9O6RbVFtp-4uRNepAWdfrU",
      authDomain: "thefiringflame3210.firebaseapp.com",
      databaseURL: "https://thefiringflame3210-default-rtdb.firebaseio.com",
      projectId: "thefiringflame3210",
      storageBucket: "thefiringflame3210.appspot.com",
      messagingSenderId: "759308762331",
      appId: "1:759308762331:web:79725eda7c24b346eca0fe"
    };
    const ICE_SERVERS = [{ urls: 'stun:stun.l.google.com:19302' }, { urls: 'stun:stun1.l.google.com:19302' }];
    /*****************************************************/

    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.database();
    const playersRef = db.ref('players');
    const usersRef = db.ref('users');

    function el(id){ return document.getElementById(id); }
    function showAuthStart(){ el('authStart').style.display='flex'; el('appMain').style.display='none'; el('viewerFull').style.display='none'; const leftLogo = el('leftLogo'); if (leftLogo) leftLogo.style.visibility = 'hidden'; updateTopForUser(null); }
    function showViewerFull(){ el('authStart').style.display='none'; el('viewerFull').style.display='block'; el('appMain').style.display='none'; const leftLogo = el('leftLogo'); if (leftLogo) leftLogo.style.visibility = 'visible'; }
    function showAppMain(){ el('authStart').style.display='none'; el('viewerFull').style.display='none'; el('appMain').style.display='block'; const leftLogo = el('leftLogo'); if (leftLogo) leftLogo.style.visibility = 'visible'; }

    // show fallback logos if image not found (runs after DOM load)
    window.addEventListener('load', ()=>{
      const leftImg = el('leftLogoImg'); if (!leftImg || leftImg.naturalWidth === 0) { const lf = el('leftLogoFallback'); if (lf) lf.style.display='block'; }
      const cornerImg = el('cornerLogoImg'); if (!cornerImg || cornerImg.naturalWidth === 0) { const cf = el('cornerLogoFallback'); if (cf) cf.style.display='block'; }
    });

    // QUESTIONS logic (unchanged)
    const questions = [
      { q: "What is this for?", a: "Live Tab Sharing lets a host share a browser tab or entire screen in real time with viewers. Hosts create Players, start sharing, and viewers connect to watch. Hosts control access (kick), select quality, and optionally enable remote control. Streams use WebRTC and are encrypted. Firebase stores only session metadata (no media recordings)."},
      { q: "Why choose us?", a: "Fast peer-to-peer streaming for low latency, simple viewer management, optional remote controls and lightweight integration — great for demos and collaborative sessions."},
      { q: "How is privacy handled?", a: "Streams are WebRTC (encrypted). We only store minimal session metadata in Firebase. We don't record streams by default; hosts must explicitly enable recording."},
      { q: "Can I revoke access?", a: "Yes — the host can kick viewers or stop sharing; when sharing stops all viewers disconnect automatically."},
      { q: "What quality should I use?", a: "Use 720p@30 for clear presentations. Use 480p@15 if you or your viewers have limited bandwidth."},
      { q: "Does it record sessions?", a: "No automatic recording. If recording is enabled the host will notify viewers. Otherwise sessions are transient."},
      { q: "Can I share audio?", a: "Depending on browser/OS, you can share a tab's audio or system audio when selecting the right capture options."},
      { q: "What if the host disconnects?", a: "Viewers are disconnected when the host loses connection. The host can re-create a Player to resume sharing."},
      { q: "How many viewers are supported?", a: "No fixed limit, but the host's upload bandwidth and CPU affect simultaneous viewer experience."},
      { q: "Are connections encrypted?", a: "Yes — media uses WebRTC (DTLS/SRTP). Metadata in Firebase is standard session info (peer IDs, timestamps)."}
    ];

    let mainIndex = 0, btnA = 1, btnB = 2, nextPointer = 3;
    function setMainQuestion(i){ mainIndex = i % questions.length; el('mainQTitle').innerText = questions[mainIndex].q; el('mainAnswer').querySelector('.answer-text').innerText = questions[mainIndex].a; }
    function setButtonTexts(){ el('qBtn1').innerText = questions[btnA % questions.length].q; el('qBtn2').innerText = questions[btnB % questions.length].q; }
    el('qBtn1').addEventListener('click', ()=>{ const clickedIndex = btnA % questions.length; setMainQuestion(clickedIndex); btnA = nextPointer % questions.length; nextPointer = (nextPointer + 1) % questions.length; setButtonTexts(); });
    el('qBtn2').addEventListener('click', ()=>{ const clickedIndex = btnB % questions.length; setMainQuestion(clickedIndex); btnB = nextPointer % questions.length; nextPointer = (nextPointer + 1) % questions.length; setButtonTexts(); });
    setMainQuestion(0); setButtonTexts();

    // AUTH wiring (modified register to add tokens)
    el('tabLogin').addEventListener('click', ()=>{ el('tabLogin').classList.add('active'); el('tabRegister').classList.remove('active'); el('loginForm').style.display = 'flex'; el('registerForm').style.display = 'none'; });
    el('tabRegister').addEventListener('click', ()=>{ el('tabRegister').classList.add('active'); el('tabLogin').classList.remove('active'); el('loginForm').style.display = 'none'; el('registerForm').style.display = 'flex'; });

    el('visualSubmit').addEventListener('click', async ()=>{ const email = el('visualEmail').value.trim(); const pass = el('visualPassword').value; if (!email || !pass) { el('loginMsg').innerText = 'Introduce email y contraseña'; return; } el('loginMsg').innerText = 'Iniciando sesión...'; try { await auth.signInWithEmailAndPassword(email, pass); el('loginMsg').innerText = 'Sesión iniciada'; } catch(e){ el('loginMsg').innerText = 'Error: ' + (e.message||e); } });

    el('registerBtnVisual').addEventListener('click', async ()=>{ const email = el('regEmail').value.trim(); const pass = el('regPassword').value; const username = el('regUsername').value.trim(); if (!email || !pass || !username){ el('regMsg').innerText = 'Rellena todos los campos'; return; } el('regMsg').innerText = 'Creando cuenta...'; try { const cred = await auth.createUserWithEmailAndPassword(email, pass); const uid = cred.user.uid; // give new user 100 tokens
        await usersRef.child(uid).set({ username, tokens: 100 }); el('regMsg').innerText = 'Cuenta creada. Inicia sesión.'; el('tabLogin').click(); el('visualEmail').value = email; } catch(e){ el('regMsg').innerText = 'Error: ' + (e.message||e); } });
    el('cancelRegVisual').addEventListener('click', ()=> el('tabLogin').click() );

    el('forgotLink').addEventListener('click', async (ev)=>{ ev.preventDefault(); const email = el('visualEmail').value.trim(); if (!email) return alert('Introduce tu correo en el campo de email para recibir un enlace de recuperación.'); try { await auth.sendPasswordResetEmail(email); alert('Se ha enviado un correo para restablecer la contraseña.'); } catch(e){ alert('Error: ' + (e.message||e)); } });

    // Peer + players integration (preserved and integrated)
    let currentUser = null, currentProfile = null, viewerPeer = null, playersSnapshot = {}, connectedMap = {};
    function peerOptions(){ return { config:{ iceServers: ICE_SERVERS } }; }

    // update top header when user changes
    function updateTopForUser(profile){
      const nameEl = el('usernameDisplay');
      const tokensEl = el('tokensDisplay');
      if (!profile){ if (nameEl) nameEl.innerText = 'Guest'; if (tokensEl) tokensEl.innerText = '0'; return; }
      if (nameEl) nameEl.innerText = profile.username || 'User';
      if (tokensEl) tokensEl.innerText = (profile.tokens != null) ? profile.tokens : 0;
    }

    // ensure viewer peer — updated to attach incoming stream to center big area
    function ensureViewerPeer(){
      if (viewerPeer) return;
      viewerPeer = new Peer(peerOptions());
      viewerPeer.on('open', id=> console.log('viewer peer open', id));
      viewerPeer.on('error', err=> console.warn('viewer peer err', err));

      // when a host calls us, attach the remote stream into the big center canvas
      viewerPeer.on('call', call=>{
        call.on('stream', remoteStream=>{
          // clear the center area and show video
          const container = el('viewerVideoContainer');
          if (!container) return;
          container.innerHTML = ''; // remove placeholder
          const video = document.createElement('video');
          video.autoplay = true;
          video.playsInline = true;
          video.srcObject = remoteStream;
          video.style.width = '100%';
          video.style.height = '100%';
          video.style.objectFit = 'contain';
          container.appendChild(video);

          // when stream ends, restore placeholder and mark downtime start in DB (done by host)
          remoteStream.getTracks().forEach(t => {
            t.onended = ()=>{
              // restore placeholder content (will be computed from selected player)
              // set UI status
              const st = el('shareStatusLabel'); if (st) st.innerText = 'Status: Not sharing';
              // if selected player exists, show its NOT CURRENTLY SHARING UI:
              const selectedBadge = el('currentPlayerBadge').innerText;
              // UI will follow DB updates via re-render
            };
          });

          const st = el('shareStatusLabel'); if (st) st.innerText = 'Status: Playing';
        });

        call.on('error', e=> console.warn('call error', e));
      });
    }

    // render players for viewer left column (updated with status logic & purchase indicator)
    function renderPlayersViewer(snapshot){
      const container = el('playersListViewer'); if (!container) return;
      container.innerHTML = '';
      const keys = Object.keys(snapshot || {});
      if (keys.length === 0){ container.innerHTML = '<div class="small-muted" style="padding:12px">No Players available.</div>'; return; }

      // sort by createdAt
      keys.sort((a,b)=> (snapshot[a]?.createdAt||0) - (snapshot[b]?.createdAt||0) );

      let anySelected = false;
      keys.forEach((pid, idx)=>{
        const p = snapshot[pid] || {};
        const item = document.createElement('div');
        item.className = 'player-item';
        item.dataset.pid = pid;

        const left = document.createElement('div');
        left.style.display='flex'; left.style.alignItems='center';
        const name = document.createElement('div'); name.className='name'; name.innerText = p.title || `Player ${idx+1}`;
        left.appendChild(name);

        // show renter tag
        if (p.renterUid) {
          const rentTag = document.createElement('div');
          rentTag.style.marginLeft='10px'; rentTag.style.fontSize='12px'; rentTag.style.color='#6b7280';
          rentTag.innerText = '(rented)';
          left.appendChild(rentTag);
        }

        const right = document.createElement('div');
        right.style.display='flex'; right.style.alignItems='center';

        const dot = document.createElement('div'); dot.className='status-dot';
        // status color rules:
        // - Green: the player is currently inside a roblox game (p.inGame === true)
        // - Red: broadcaster is sharing the screen but not in roblox (p.peerId exists && !p.inGame)
        // - Orange: broadcaster not sharing (no peerId) -> then NOT CURRENTLY SHARING and downtime accumulates
        if (p.inGame) dot.style.background = '#16a34a'; // green
        else if (p.peerId) dot.style.background = '#ef4444'; // red
        else dot.style.background = '#f97316'; // orange

        right.appendChild(dot);

        item.appendChild(left);
        item.appendChild(right);

        // visual selection if matches currently selected (we keep lastSelectedPid)
        if (window._lastSelectedPid && window._lastSelectedPid === pid){
          item.classList.add('selected'); anySelected = true;
        }

        item.addEventListener('click', ()=>{
          // deselect previous
          const prev = container.querySelector('.player-item.selected'); if (prev) prev.classList.remove('selected');
          item.classList.add('selected');
          window._lastSelectedPid = pid;

          // update current player badge
          const badge = el('currentPlayerBadge'); if (badge) badge.innerText = 'Current Player: ' + (p.title || pid);

          // if player is rented and current user not renter nor owner -> show rented info and prevent connection
          if (p.renterUid && currentUser && currentUser.uid !== p.renterUid && currentUser.uid !== p.owner){
            const center = el('viewerVideoContainer');
            center.innerHTML = `<div style="font-size:20px;color:#444">This Player is rented by another user until ${p.rentalExpires ? new Date(p.rentalExpires).toLocaleString() : '—'}</div>`;
            el('shareStatusLabel').innerText = 'Status: Rented';
            return;
          }

          // else if peer present -> connect
          if (p.peerId){
            connectToPlayerAsViewer(pid);
            el('shareStatusLabel').innerText = 'Status: Connecting...';
          } else {
            // show NOT CURRENTLY SHARING (downtime accumulation)
            renderNotSharingUI(pid, p);
            el('shareStatusLabel').innerText = 'Status: Not sharing';
          }
        });

        container.appendChild(item);
      });

      // if nothing selected, show select message in center
      if (!anySelected){
        showSelectMessage();
      }
    }

    function renderNotSharingUI(pid, p){
      const center = el('viewerVideoContainer');
      if (!center) return;
      center.innerHTML = '';
      const div = document.createElement('div');
      div.style.textAlign='center';
      div.style.fontSize='34px';
      div.style.color='#666';
      div.innerHTML = `—NOT CURRENTLY SHARING—<br/><span style="font-size:20px;color:#444">(Fixing Soon &amp; Compensating Time)</span><div style="margin-top:18px;font-weight:800;color:#c00" id="downDisplay-${pid}">DOWN TIME: ${formatMs(computeDowntime(p))}</div>`;
      center.appendChild(div);
    }

    // Host render (update to include 'inGame' toggle and unlink renter control)
    function renderPlayersHost(snapshot){
      const container = el('playersGrid'); if (!container) return; container.innerHTML = '';
      for (const playerId in snapshot){
        const p = snapshot[playerId] || {};
        const elDiv = document.createElement('div');
        elDiv.className='player';
        elDiv.id = 'pl-' + playerId;
        elDiv.innerHTML = `<div class="title" style="font-weight:900;color:#0b2b66;font-size:18px">${p.title || playerId}</div>
          <div class="meta" style="font-size:.9rem;color:var(--muted);margin-top:6px">Owner: <strong>${p.ownerName||p.owner||'—'}</strong> • Peer: <span class="peer-id">${p.peerId || '—'}</span></div>
          <div class="preview" style="flex:1;border-radius:8px;margin-top:8px;overflow:hidden;background:linear-gradient(180deg,#f7fbff,#ffffff);display:flex;align-items:center;justify-content:center"><div class="muted small">No se comparte</div></div>
          <div class="host-controls" style="margin-top:8px"></div>
          <div style="margin-top:8px"><div class="small-muted">Conectados:</div><div class="viewer-list small-muted" style="margin-top:6px;max-height:90px;overflow:auto"></div></div>`;

        container.appendChild(elDiv);

        const controls = elDiv.querySelector('.host-controls');
        // share button
        const shareBtn = document.createElement('button'); shareBtn.className='btn btn-sm btn-outline-primary'; shareBtn.innerText = p.peerId ? 'Compartiendo' : 'Compartir';
        shareBtn.addEventListener('click', ()=>{ if (!currentUser || currentUser.uid !== p.owner) return toast('Solo el owner puede compartir','danger'); startSharingForExistingPlayer(playerId, elDiv); });
        controls.appendChild(shareBtn);

        // copy peer
        const copyBtn = document.createElement('button'); copyBtn.className='btn btn-sm btn-outline-secondary'; copyBtn.innerText='Copiar Peer';
        copyBtn.addEventListener('click', ()=>{ const pidText = elDiv.querySelector('.peer-id').textContent; if (!pidText || pidText === '—') return toast('No hay PeerID','info'); navigator.clipboard.writeText(pidText).then(()=>toast('PeerID copiado','success')).catch(()=>toast('No se pudo copiar','danger')); });
        controls.appendChild(copyBtn);

        // toggle inGame
        const inGameBtn = document.createElement('button'); inGameBtn.className='btn btn-sm btn-outline-info'; inGameBtn.innerText = p.inGame ? 'In Game ✓' : 'Toggle InGame';
        inGameBtn.addEventListener('click', async ()=>{
          if (!currentUser || currentUser.uid !== p.owner) return toast('Solo el owner puede cambiar','danger');
          await playersRef.child(playerId).update({ inGame: !p.inGame });
          toast('inGame toggled','success');
        });
        controls.appendChild(inGameBtn);

        // unlink renter / kick renter
        if (p.renterUid) {
          const unlinkBtn = document.createElement('button'); unlinkBtn.className='btn btn-sm btn-outline-danger'; unlinkBtn.innerText='Unlink Renter';
          unlinkBtn.addEventListener('click', async ()=>{
            if (!currentUser || currentUser.uid !== p.owner) return toast('Solo el owner puede kickear','danger');
            await playersRef.child(playerId).update({ renterUid: null, available: true, rentedAt: null, rentalExpires: null });
            toast('Renter unlinked','info');
          });
          controls.appendChild(unlinkBtn);
        }

        // delete button (owner only)
        const delBtn = document.createElement('button'); delBtn.className='delete-btn'; delBtn.title='Eliminar'; delBtn.style.marginLeft='auto'; delBtn.style.border='none'; delBtn.style.background='transparent'; delBtn.style.color='#e04b4b'; delBtn.style.fontWeight='700'; delBtn.innerText = '×';
        delBtn.addEventListener('click', ()=>{ if (!currentUser) return toast('No autenticado','info'); if (p.owner && currentUser.uid !== p.owner) return toast('Solo el owner puede eliminar','danger'); playersRef.child(playerId).remove(); toast('Player eliminado','info'); });
        elDiv.appendChild(delBtn);

        // viewer list rendering
        const viewers = p.viewers || {}; const viewerListDiv = elDiv.querySelector('.viewer-list');
        if (Object.keys(viewers).length === 0) viewerListDiv.innerHTML = `<div class="muted small">Nadie conectado</div>`; else {
          viewerListDiv.innerHTML=''; for (const uid in viewers){ const v = viewers[uid] || {}; const item = document.createElement('div'); item.style.display='flex'; item.style.justifyContent='space-between'; item.style.alignItems='center'; item.style.marginBottom='6px'; item.innerHTML = `<div>${v.username || uid} ${v.kicked ? '(kicked)' : v.active ? '(activo)' : '(inactivo)'}</div><div><button class="btn btn-sm btn-outline-danger kick-btn">Kick</button></div>`; const kickBtn = item.querySelector('.kick-btn'); kickBtn.addEventListener('click', ()=>{ if (!currentUser || currentUser.uid !== p.owner) return toast('Solo el owner puede kickear','danger'); playersRef.child(playerId).child('viewers').child(uid).update({ kicked: true, active:false }); toast('Kick enviado a ' + (v.username||uid),'info'); }); viewerListDiv.appendChild(item); }
        }
      }
    }

    function getNextPlayerNumber(){ return Object.keys(playersSnapshot || {}).length + 1; }

    // if owner clicks addPlayer we still create an unsold player (forSale true) for sale by default
    document.addEventListener('click', async function(e){
      if (e.target && e.target.id === 'addPlayer'){
        // open buy modal for viewers (or owners who want to buy)
        openBuyModal();
      }
    });

    // when owner creates player elsewhere: keep previous creation handler for adding a player (for owners)
    // (if you want owners to create players via a different UI, keep using playersRef.child(...).set(...))
    // For completeness, hooking the old 'create player' pattern to a keyboard shortcut helps quick testing:
    document.addEventListener('keydown', function(e){
      if (e.ctrlKey && e.key === 'n'){ // ctrl+n to create a player as current user (for owners)
        if (!currentUser) return toast('Inicia sesión para crear Player','info');
        const idx = getNextPlayerNumber(); const pid = `player-${Date.now()}-${Math.floor(Math.random()*999)}`; const ownerName = currentProfile.username;
        // new player for sale by default, price 10
        playersRef.child(pid).set({ owner: currentUser.uid, ownerName: ownerName, title: `Player ${idx}`, peerId: '', viewers: {}, locked: false, createdAt: Date.now(), forSale:true, price:10, available:true, inGame:false, downAccumulated:0, downSince: null });
        toast('Player creado (for sale)','success');
      }
    });

    // startSharingForExistingPlayer (modified with downtime accumulation)
    async function startSharingForExistingPlayer(playerId, elDom){
      const pSnap = playersSnapshot[playerId] || {};
      if (!currentUser || pSnap.owner !== currentUser.uid) return toast('No eres el owner','danger');
      try {
        let width=1280,height=720,fps=15;
        const qualityEl=document.getElementById('quality');
        if (qualityEl){ const q=qualityEl.value.split('@')[0].split('x'); width=parseInt(q[0])||1280;height=parseInt(q[1])||720;fps=parseInt(qualityEl.value.split('@')[1]||'15'); }
        const stream = await navigator.mediaDevices.getDisplayMedia({ video:{ width, height, frameRate: fps }, audio:false });
        const peer = new Peer(peerOptions());
        elDom._playerPeer = peer; elDom._stream = stream;

        peer.on('open', async id=>{
          // If player had downSince, add to downAccumulated
          const p = playersSnapshot[playerId] || {};
          let updates = { peerId: id, title: pSnap.title || 'Player' };
          if (p.downSince){
            const extra = Date.now() - p.downSince;
            updates.downAccumulated = (p.downAccumulated || 0) + extra;
            updates.downSince = null;
          }
          await playersRef.child(playerId).update(updates);
          toast('Peer listo: ' + id, 'success');
        });

        peer.on('connection', conn=>{
          conn.on('open', ()=>{
            conn.on('data', data=>{
              if (data && data.type === 'request'){
                const viewerUid = data.viewerUid;
                const username = data.username || 'guest';
                const viewerRef = playersRef.child(playerId).child('viewers').child(viewerUid);
                viewerRef.update({ username, connectedAt: Date.now(), active: true, kicked: false });
                const call = peer.call(conn.peer, stream);
                call.on('error', e=>console.error('Call err', e));
              } else if (data && data.type === 'control'){
                window.dispatchEvent(new CustomEvent('remote-control', { detail: data }));
              }
            });
          });
        });

        peer.on('call', call => call.answer(stream));

        // when stream ends: mark peerId empty and start downtime
        stream.getTracks().forEach(t => t.onended = async ()=> {
          await playersRef.child(playerId).update({ peerId: '' , downSince: Date.now() });
          // mark all viewers inactive
          playersRef.child(playerId).child('viewers').once('value').then(snap=>{
            const vs = snap.val() || {}; for (const uid in vs) playersRef.child(playerId).child('viewers').child(uid).update({ active:false });
          });
          if (elDom._playerPeer) try { elDom._playerPeer.destroy(); } catch(e){}
        });

        // show preview inside host UI if exists
        const preview = elDom.querySelector('.preview');
        if (preview){
          preview.innerHTML=''; const v=document.createElement('video'); v.autoplay=true; v.playsInline=true; v.muted=true; v.srcObject = stream; v.style.width='100%'; preview.appendChild(v);
        }
      } catch(e){ toast('Error compartiendo: ' + (e.message || e),'danger'); }
    }

    // connectToPlayerAsViewer — updated to enforce rental exclusivity
    function connectToPlayerAsViewer(playerId){
      if (!currentUser) return toast('Inicia sesión para conectar','danger');
      const p = playersSnapshot[playerId] || {};
      // if rented and not the renter and not owner => block
      if (p.renterUid && p.renterUid !== currentUser.uid && currentUser.uid !== p.owner) {
        return toast('Este player está alquilado por otro usuario','info');
      }
      if (!p.peerId) {
        // show not sharing UI (downtime)
        renderNotSharingUI(playerId, p);
        el('shareStatusLabel').innerText = 'Status: Not sharing';
        return;
      }

      ensureViewerPeer();
      const badge = el('currentPlayerBadge'); if (badge) badge.innerText = 'Current Player: ' + (p.title || playerId);
      const st = el('shareStatusLabel'); if (st) st.innerText = 'Status: Connecting...';

      try {
        const peerId = p.peerId;
        const conn = viewerPeer.connect(peerId, { reliable:true });
        conn.on('open', ()=>{
          conn.send({ type:'request', viewerUid: currentUser.uid, username: currentProfile.username });
          playersRef.child(playerId).child('viewers').child(currentUser.uid).update({ username: currentProfile.username, connectedAt: Date.now(), active:true, kicked:false });
          toast('Conectado: ' + (p.title || playerId),'success');
          if (st) st.innerText = 'Status: Request sent';
        });
        conn.on('error', e=> { console.error('dataConn error', e); toast('Error de conexión','danger'); if (st) st.innerText = 'Status: Error'; });
      } catch(e){
        console.error('connectToPlayerAsViewer err', e);
        toast('Error: ' + (e.message||e),'danger');
        if (st) st.innerText = 'Status: Error';
      }
    }

    // BUY modal logic
    function openBuyModal(){
      const modal = el('buyModal'); if (!modal) return;
      populateSaleList();
      modal.style.display = 'block';
      document.getElementById('closeBuy').onclick = ()=> modal.style.display='none';
    }

    function populateSaleList(){
      const saleDiv = el('saleList'); if (!saleDiv) return; saleDiv.innerHTML = '';
      const keys = Object.keys(playersSnapshot || {});
      const sales = keys.filter(k => {
        const p = playersSnapshot[k] || {};
        return p.forSale && p.available;
      });
      if (sales.length === 0) {
        saleDiv.innerHTML = '<div class="small-muted">No players currently available to buy.</div>'; return;
      }
      sales.forEach(pid=>{
        const p = playersSnapshot[pid] || {};
        const row = document.createElement('div'); row.style.display='flex'; row.style.justifyContent='space-between'; row.style.alignItems='center'; row.style.padding='8px'; row.style.border='1px solid rgba(0,0,0,.06)'; row.style.borderRadius='8px';
        const left = document.createElement('div'); left.innerHTML = `<div style="font-weight:800">${p.title || pid}</div><div style="font-size:12px;color:#6b7280">Owner: ${p.ownerName||p.owner||'—'}</div>`;
        const right = document.createElement('div'); right.style.display='flex'; right.style.gap='8px'; const price = document.createElement('div'); price.style.fontWeight='900'; price.innerText = `${p.price || 10} tokens`;
        const buyBtn = document.createElement('button'); buyBtn.className='submit-btn'; buyBtn.style.width='140px'; buyBtn.innerText='Buy';
        buyBtn.addEventListener('click', ()=> attemptBuy(pid));
        right.appendChild(price); right.appendChild(buyBtn);
        row.appendChild(left); row.appendChild(right);
        saleDiv.appendChild(row);
      });
    }

    // atomic purchase: deduct tokens and claim the player if still available
    async function attemptBuy(pid){
      if (!currentUser) return toast('Inicia sesión para comprar','info');
      const uid = currentUser.uid;
      const price = (playersSnapshot[pid] && playersSnapshot[pid].price) || 10;
      // transaction on players to ensure available
      try {
        // first ensure user has enough tokens via transaction on user tokens
        const tokensRef = usersRef.child(uid).child('tokens');
        const tokensResult = await tokensRef.transaction(current => {
          if (current == null) return; // abort if user doesn't exist (shouldn't happen)
          if (current < price) return; // abort by returning undefined
          return current - price;
        }, undefined, false);
        if (!tokensResult.committed){
          return toast('No tienes suficientes tokens','danger');
        }
        // now claim player atomically
        const playerRef = playersRef.child(pid);
        const playerResult = await playerRef.transaction(current=>{
          if (!current) return; // abort
          if (!current.available) return; // already taken -> abort
          current.available = false;
          current.renterUid = uid;
          current.rentedAt = Date.now();
          current.rentalExpires = Date.now() + 24*3600*1000;
          return current;
        }, undefined, false);
        if (!playerResult.committed){
          // refund tokens if player not available
          await tokensRef.transaction(current => (current||0) + price);
          return toast('El player fue comprado por alguien más, tokens devueltos','info');
        }
        // success
        toast('Compra completada. Tienes el acceso por 24h','success');
        el('buyModal').style.display='none';
      } catch(e){
        console.error('buy err', e);
        toast('Error en la compra','danger');
      }
    }

    // helper compute downtime for player
    function computeDowntime(p){
      const acc = p.downAccumulated || 0;
      const ds = p.downSince || null;
      let total = acc;
      if (ds) total += (Date.now() - ds);
      return total;
    }
    function formatMs(ms){
      if (!ms || ms < 0) ms = 0;
      const s = Math.floor(ms/1000);
      const h = Math.floor(s/3600); const m = Math.floor((s%3600)/60); const sec = s%60;
      return `${h}h ${m}m ${sec}s`;
    }

    // periodically update downtime display for selected player and expiry handling
    setInterval(()=>{
      // update selected player's down display
      const sel = window._lastSelectedPid;
      if (sel){
        const p = playersSnapshot[sel];
        if (p && (!p.peerId)){
          const elDown = document.getElementById('downDisplay-' + sel);
          if (elDown) elDown.innerText = 'DOWN TIME: ' + formatMs(computeDowntime(p));
        }
      }
      // check rentals expiration
      const now = Date.now();
      for (const pid in playersSnapshot){
        const p = playersSnapshot[pid] || {};
        if (p.rentalExpires && p.rentalExpires <= now){
          // clear rental, make available again
          playersRef.child(pid).update({ renterUid: null, available: true, rentedAt: null, rentalExpires: null });
        }
      }
    }, 1000);

    // DB listeners
    playersRef.on('value', snap=>{ playersSnapshot = snap.val() || {}; renderPlayersViewer(playersSnapshot); renderPlayersHost(playersSnapshot); populateSaleList(); });
    db.ref('.info/connected').on('value', snap=>{ const v=snap.val(); const fb = el('fbLabel'); if (fb) fb.textContent = v ? 'Conectado' : 'Desconectado'; });

    // when auth status changes
    auth.onAuthStateChanged(async user=>{
      if (!user){ currentUser=null; currentProfile=null; showAuthStart(); updateTopForUser(null); return; }
      currentUser = user;
      const snap = await usersRef.child(user.uid).once('value');
      currentProfile = snap.val() || { username: user.email.split('@')[0], tokens: 0 };
      // update top UI
      updateTopForUser(currentProfile);
      // decide view
      const playersNow = (await playersRef.once('value')).val() || {};
      const owns = Object.values(playersNow||{}).some(p=> p && p.owner === currentUser.uid);
      if (owns) showAppMain(); else { showViewerFull(); ensureViewerPeer(); }
    });

    // when registering, usersRef already gets tokens:100 (done earlier)

    // small helper toast
    function toast(msg, type='info'){
      const t = document.createElement('div'); t.className='toast'; t.innerText = msg; document.body.appendChild(t);
      setTimeout(()=> t.style.opacity='0', 2600);
      setTimeout(()=> t.remove(), 3000);
    }

    // UI helpers
    function showSelectMessage(){
      const center = el('viewerVideoContainer');
      if (!center) return;
      center.innerHTML = '<div id="selectMessage" style="font-size:38px;color:#444">Select A Player</div>';
      el('currentPlayerBadge').innerText = 'Select A Player';
      el('shareStatusLabel').innerText = 'Status: —';
    }

    // close buy modal on clicking overlay
    document.addEventListener('click', (ev)=>{
      const modal = el('buyModal');
      if (!modal) return;
      if (ev.target && ev.target.id === 'buyOverlay'){
        modal.style.display='none';
      }
    });

    // back arrow inside center frame -> go back to authStart as requested
    el('viewArrow').addEventListener('click', ()=> showAuthStart());

    // update header tokens display when user profile changes in db (listen to user's profile)
    auth.onAuthStateChanged(user=>{
      if (!user) return;
      usersRef.child(user.uid).on('value', snap=>{
        const data = snap.val() || {};
        currentProfile = data;
        updateTopForUser(currentProfile);
      });
    });

    // initial
    showAuthStart();
  </script>
</body>
</html>
